近期面试

### 待补充知识点

1. 基础算法的手写

   1. 快速排序

2. k8s和es的基础知识

   1. k8s管理容器
   2. es全文检索

3. List和set的区别

4. 树的深度和广度遍历是怎么样过程

5. 抽象类可不可以实例化

   抽象类被继承后，继承类实例化，会触发抽象类的构造函数

   但是不能直接使用new关键字去实例化

   ~~~java
   abstract class B {
       private String str;
       
       public B(String a) {
           System.out.println("父类已经实例化");
           this.str=a;
           System.out.println(str);
       }
       
       public abstract void play();
   }
   
   public class A extends B{
   
       public A(String a) {
           super(a);
           System.out.println("子类已经实例化");
       }
   
       @Override
       public void play() {
           System.out.println("我实现了父类的方法");
       }
       
       public static void main(String[] args) {
           B aa=new A("a");
       }
   }
   
   父类已经实例化
   a
   子类已经实例化
   ~~~

   

   Jvm的内存结构，解释都是干什么用？
   解释下指针的概念
   object类的方法有哪些
   List和set的区别
   还有一些内存泄漏的相关知识
   介绍死锁及其解决办法

   分布式锁、数据库事务特性、隔离机制、一致性hash算法、负载路由几种算法、微服务架构、常用设计模式、redis集群模式，多线程、tcp三次握手、http协议，xx框架怎么做到高可用等等，然后有一些案例问你的解决方案。

   第二轮(30-40分钟)：kafka，springcloud，web安全，有没有做过springcloud的性能压测，为什么从xx框架换到xx框架，做过哪些性能调优等等。坐等第三轮面试，谁知道第三轮面试是啥？不会还是技术面吧？

---

### JVM内存结构

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。栈（数据结构）：一种先进后出的数据结构。

堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。

栈是运行时单位，堆是存储单位；栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。**但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美**

参考：[JVM调优总结](https://www.cnblogs.com/andy-zhou/p/5327288.html)

#### JVM内存模型

* jvm线程共享区域
  * heap堆：java对象，垃圾回收重点区域
  * 元数据（方法区）：final，static等常量，类信息（类方法，接口等）、运行时常量池

* jvm线程私有区域
  * 虚拟机栈：线程中每个方法执行时，创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，局部变量
  * 本地方法栈：native调用本地方法
  * 程序计数器：字节码指令、程序控制流的指示器，分支、循环、跳转、异常处 理、线程恢复等基础功能都需要依赖这个计数器来完成。

#### JVM的gc算法

gc调优：heap内存的合理分配。设置年轻代和老年代的比值，调整gc回收器的选择

标记清除：

一阶段对于被引用的对象进行标记。二阶段遍历整个heap，对所有未标记的对象进行清除。

缺点-会产生内存碎片，且需要暂停应用

复制：

每次只是用内存区域的一般。gc时，将正在使用的对象复制到另一半空闲区域同时整理。

缺点：内存区域真正使用的只有一半

标记整理：

一阶段标记被引用的对象，二阶段清理未被标记的对象，同时整理未被清除的对象到堆的一块连续内存区域

#### JVM的gc策略

TODO

#### JVM类加载过程

TODO

### 基本数据结构

* 常用基本数据结构

![](数据结构分类.jpg)

1集合：数组

线性结构：栈、队列、链表

树形结构：堆

图形结构：散列表、图

* 数据结构分类：

  集合，线性结构，树形结构，图形结构（树、图也被称为非线性）

  1. 集合

     ![](集合.png)

     数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；

  2. 线性结构

     数据结构中的元素存在一对一的相互关系

     线性结构的特点：在数据元素有限集中，除第一个元素无直接前驱，最后一个元素无直接后续以外，每个数据元素有且仅有一个直接前驱元素和一个直接后继元素。

     线性表定义：n个类型相同数据元素的有限序列。

     常用的线性结构：线性表、栈、队列、链表、数组

     栈：

     <img src="栈.jpg" style="zoom:50%;" />

     队列：

     <img src="队列.jpg" style="zoom:50%;" />

     链表：

     <img src="链表.jpg" style="zoom:70%;">

     

     数组：

     <img src="数组.jpg" style="zoom:30%;" />

     注：线性表，栈和队列、数组的异同

     都是线性结构，都是逻辑结构的概念。都可以用顺序存储或链表存储；栈和队列是两种特殊的线性表，即受限的线性表，只是对插入、删除运算加以限制。

     线性表是一种抽象数据类型；数组是一种具体的数据结构，线性表是元素之间具有1对1的线性关系的数据元素的集合，而数组是具体的实现，即一组数据元素到数组下标的一一映射

  3. 树形结构

     **树**是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。

     拓展树（平衡二叉树、红黑树、B+树）

     简单二叉树：

     * 每个结点最多有两颗子树，结点的度最大为2。
     * 左子树和右子树是有顺序的，次序不能颠倒。
     * 即使某结点只有一个子树，也要区分左右子树。

     <img src="树.jpg" style="zoom:50%;" />

     堆：

     - 堆中某个节点的值总是不大于或不小于其父节点的值；
     - 堆总是一棵完全二叉树。

     <img src="堆.jpg" style="zoom:50%;" />

     平衡二叉树：

     **它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。**

     <img src="平衡二叉树.jpg" style="zoom:50%;" />

     二叉查找树：

     也称二叉搜索树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：
  
     * 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
     * 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
   * 任意节点的左、右子树也分别为二叉查找树；
     * 没有键值相等的节点。

     ![](二叉查找树.jpg)

     红黑树：
  
     * 每个个节点或者是黑色，或者是红色。
   * 根节点是黑色。
     * 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！如果一个节点是红色的，则它的子节点必须是黑色的。
   * 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
  
   <img src="红黑树.jpg" style="zoom:50%;" />
  
   b-树：b-树就是b树，不存在b减树的读法
  
   b树相对以二叉查找树的优点：减少了磁盘IO，索引树的高度表示了索引IO次数
  
   一个m阶的B树具有如下几个特征
  
   * 根结点至少有两个子女。
  
   * 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
     * 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
   * 所有的叶子结点都位于同一层。
     * 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

     由于b树有众多条件限制，所以他是一个自平衡的树

     ![](b-树.jpg)

     b树的值域划分：

     ![](b-树的值域划分.jpg)
  
     b+树：
  
     * 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
     * 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
     * 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
  
     <img src="b+树.jpg" style="zoom:50%;" />
  
     B-树和B+树的区别：
  
     * 相对于b树b+树更加的'矮胖'。更加的减少磁盘IO次数。b+树除了叶子节点外，其他节点都不存储卫星数据，只存储索引数据。b树每个节点有索引又有卫星数据；卫星数据及索引对应的数据
  
     注：
  
     b+树怎么实现索引功能：
  
     https://blog.csdn.net/qq_26222859/article/details/80631121
  
  4. 散列表
  
     也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。
  
     HashMap，HashTable等，利用hash表的优势
  
     因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组结合链表的一种结构
  
     jdk1.8之后才换成了数组加红黑树的结构
  
     <img src="散列表.jpg" style="zoom:50%;" />
  
  5. 图性结构
  
     图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。
  
     <img src="图.jpg" style="zoom:50%;" />

#### 基础数据结构的编码实现

二叉树，前序后序的编码实现

#### 简单集合类的代码底层原理

HashMap：

![](hashmapandhashset.jpg)

hashmap在put的时候，我们把每次put进入hashmap的数据称之为为entry，hashmap的所有键值对存储在一个数组中，这个数组是hashmap的主干，首先是通过hash函数算出put的k所存放的位置。因为数组初始化长度是有限的，如果通过hash函数和k计算出重复的entry存放位置，可以通过链表的形式存储。

同样get的时候，hash函数计算k所在位置，如果计算出的位置的entry的k符合即返回。不符合判断当前节点是否存在链表，有则链式查询。

hashmap的index的计算方式：**index = HashCode（\**Key\**） & （\**Length\** - 1）** ；（Length是HashMap的长度）：

参考：[漫画：什么是HashMap？](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=21#wechat_redirect)

不允许重复的键

* JDK1.7及之前：数组+链表 

* JDK1.8：数组+链表+红黑树

HashSet:

不允许重复的值

同hashMap

ArrayList：

它是基于数组实现的List类，它封装了一个Object[]类型的数组，长度可以动态的增长

LinkedList:

![](linklist.jpg)

![](linklistandarraylist.jpg)

### 线程安全容器

线程安全：

HashTable，ConcurrentHashMap | Vector，CopyOnWrieArrayList，Collections.synchronizedList |     CopyOnWrieArraySet，Collections.synchronizedSet

不安全：

HashMap | ArrayList | HashSet

不安全会报：ConcurrentModificationException异常

分析异常原因：HashMap在put kv时，底层指令是先判断集合是否已满是否需要拓展，再put k再put v。

由于多线程调度关系，如果判断集合是否已满操作没有进行线程安全处理。可能有多个线程put 相同的k v（数据冗余）。

如果再put kv。操作没有进行线程安全处理,可能会出现数据丢失情况

arraylist 如何进行扩充，平衡二叉树原理和特点。

### Spring框架

#### aop的底层实现

通过aop注解获取需要进行操作的类（类全路径），通过反射获取类内容，通过动态代理进行代理改类是方法执行，再其方法执行前后加上自定义方法

### 线程池

1. 线程池的几种不同的创建方法

   * JDK 1.8使用Executor创建线程池实例。提供了多种方式的创建线程池的实例，newCachedThreadPool(...)、newFixedThreadPool(...)、newSingleThreadExecutor、newScheduledThreadPool等，其底层使用的是ThreadPoolExecutor，只不过Executor提供几种默认参数的ThreadPoolExecutor实现类。一般情况下，建议使用ThreadPoolExecutor，根据业务情况手动配置参数

2. 好处

   * 降低资源消耗：减少频繁的开启创建线程的时间和性能消耗
   * 提高性能：不用手动创建线程，从线程池取即可，
   * 增强系统的稳定性：线程是系统稀缺资源，统一的线程池管理有利于提供系统稳定性，方便统一管理和维护调优

3. 缺点

   * 线程池初始化时时间消耗较大
   * 线程池的使用较为复杂，需要谨慎调优，使用不当可能会触发系统异常
   * 线程池中线程优先级无法自定义调整

4. ThreadLocal

   * 用途：线程变量副本，每个线程用于自己的变量副本，相互不影响

   * 内存泄漏问题，线程强引用，不会被GC。使用完线程共享变量后，显示调用ThreadLocalMap.remove方法清除线程共享变量，让JVM自动GC

### 线程安全

#### 锁

公平/非公平

```
* 公平/非公平锁FairSync
* 公平锁：多个线程按照申请锁的顺序来获取锁
* 非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程
* 优先获取锁，可能会出现优先级反转，或者是饥饿现象（可能存在线程一直获取不到锁）
```

可重入锁（递归锁）

```
* 可重入锁(递归锁) ReentrantLock
* 线程可以进入任何一个已经获取锁的，正在同步的代码块
```

自旋锁

```
* 通过while循环，不断重试，实际没加锁（即代码无lock类）
* 基于CAS compareAndSet
```

读写锁

```
* 读写锁 ReentrantReadWriteLock
* <p>
* 多个线程同时读一个资源类，没有任何问题，为了满足并发量，读取共享资源可以同时进行
* 但是
* 如果有一个线程想写共享资源类，就不应该再有其他线程可以对该资源类进行读或者写
* 即：
* 读-读 共存
* 读-写 不共存
* 写—写 不共存
* 写操作：原子独占，不可中断
* <p>
* A\B原则
* before使用该技术前
* after使用技术后
```

#### sychronize和Reentrantlock区别

sychronize：

* 属于jvm层面的锁，底层是用的jvm的monitor
* 避免死锁，反编译后可以发现其每次都有两次的锁释放。
* 不需要手动释放锁
* 执行过程不可中断
* 非公平锁，可重入锁

Reentrantlock：

* 属于java.util.concurrent包，属于api层面的锁
* 需要手动释放锁，可能会出现死锁
* 执行过程可中断
* 公平和非公平都支持，
* 支持锁绑定多个条件condition，实现线程的部分和精准唤醒

在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？

~~~java
//使用读写锁ReentrantReadWriteLock
public class Demo{
  public static void main(String[] args){
    Mycache mycache = new Mycache();
    for(i=0;i<10;i++){
      final int finalI = i;
      new Thread(()->{
        mycache.put(i+"",i);
      },"thread-test").start();
    }
  }
}

calss MyCache{
	private volatile Map<String,Obejct> cacheMap = new HashTable<>();
  private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
  public void put(String k,Object v){
    rwLock.writeLock().lock();
    try{
      cacheMap.put(k,v)
    }catch(Exception e){
      e.printstackTrace()
    }finally{
      rwLock.writeLock().lock();
    }
  }
  public Object void get(String k){
    rwLock.readLock().lock();
    try{
      cacheMap.get(k);
    }catch(Exception){
      e.printStackTrace();
    }finally{
      rwLock.readLock.unlock();
    }
  }
}
~~~

#### 阻塞同步、非阻塞同步

阻塞\非阻塞：程序在等待调用结果时的状态

阻塞：在未返回调用结果前，当前线程会被挂起，只有调用返回数据时，线程才会继续执行

非阻塞：线程在接口调用时，不能立即得到结果，不会阻止线程。会通过其他方法，类似轮训，异步通知等操作获取调用结果

同步\异步：消息通信机制

同步：在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了

异步：发出一个调用时，立即返回，只是返回是否调用成功，调用者不会立刻得到调用结果。*被调用者*(类似接口)通过状态、通知来通知调用者，或通过回调函数处理这个调用结果。

### redis应用场景

临时token、短信通知

### sql索引以及数据库

1. 数据库查询、优化方法，sql常用函数，存储过程

   1. 优化方法

      * 关注耗时的读写是否走了索引，避免进行全表扫描

      * 避免使用selet *，查询时指定返回的具体字段

      * 使用varchar/nvarchar 代替 char/nchar

        以varchar(10)和char(10)存储3个字符长度的数据举例。varchar数据占用空间为3，最大为10；char占用的为10，3个实际字符和7个空字符

      * 索引的底层实现

   2. sql常用函数、以oracle为例

      * Avg()返回平均值，sum()返回总和
      * count()返回行数
      * MAX()、MIN() 返回列最大和最小值
      * Upper()、lower()大小写转化

   3. 存储过程是在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在数据库中，一次编译永久有效，可通过调用语句进行复用。

      **把SQL语句进行封装，并且可以使用简单的语句进行调用，这样就可以不用重复写一样的SQL，提高工作效率。**

#### 手写sql语句

5000万条数据，在500ms毫秒之内

1. 减少函数运算
2. 更改where后的条件先后排序
3. 给表添加索引

* 两个引擎

  * mysql 

    对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。

    不支持全文搜索的。同时，启动也比较的慢，它是不会保存表的行数的。锁的力度小，写操作等不会锁全表

    启动也比较的慢，它是不会保存表的行数的

  * MyIASM引擎

    不提供事务的支持，也不支持行级锁和外键

    MyIASM引擎是保存了表的行数，写操作锁全表。读效率高

  * B+树数据库引擎的底层实现

    b树：多叉树、节点支持存储多个数据

* 什么情况加索引无效

  * 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)

    注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引

  * 对索引进行了运算会导致查询不走索引，会使用全表扫描

  * 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

  * like查询是以%开头。like "AMS%"是支持的

  * 多列索引，不按照列索引顺序查询
  
    ```
    多个索引：
    INDEX name (last_name),  
    INDEX_2 name (first_name) 
    多列索引：
    INDEX name (last_name,first_name)  
    
    生效：
    SELECT * FROM test WHERE last_name='Kun' AND first_name='Li';
    sql会先过滤出last_name符合条件的记录，在其基础上在过滤first_name符合条件的记录。那如果我们分别在last_name和first_name上创建两个列索引，mysql的处理方式就不一样了，它会选择一个最严格的索引来进行检索，可以理解为检索能力最强的那个索引来检索，另外一个利用不上了，这样效果就不如多列索引了。
    
    SELECT * FROM test WHERE last_name='Widenius';  
      
    SELECT * FROM test WHERE last_name='Widenius' AND first_name='Michael';  
      
    SELECT * FROM test WHERE last_name='Widenius' AND (first_name='Michael' OR first_name='Monty');  
      
    SELECT * FROM test WHERE last_name='Widenius' AND first_name >='M' AND first_name < 'N';  
    
    不生效：
    SELECT * FROM test WHERE first_name='Michael';  
      
    SELECT * FROM test WHERE last_name='Widenius' OR first_name='Michael';  
    
    ```

#### 隔离级别

隔离性是指，多个用户的并发事务访问同一个数据库时，一个用户的事务不应该被其他用户的事务干扰，多个并发事务之间要相互隔离。	

数据库的A-原子Atomicity，C-一致Consistency，I-隔离Isolation，D-持久Durability

不考虑隔离产生的问题：

不可重复读和脏读的区别是，脏读读取到的是一个未提交的数据，而不可重复读读取到的是前一个事务提交的数据。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

* 脏读

  脏读是指一个事务在处理数据的过程中，读取到另一个为提交事务的数据

* 不可重复读

  不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了

* 幻读

  一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。

***四种隔离级别解决了上述问题***

  1.读未提交（Read uncommitted）：

这种事务隔离级别下，select语句不加锁。

此时，可能读取到不一致的数据，即“***读脏*** ”。这是并发最高，一致性最差的隔离级别。

  2.读已提交（Read committed）：

可避免 ***脏读*** 的发生。

在互联网大数据量，高并发量的场景下，几乎 **不会使用** 上述两种隔离级别。

  3.可重复读（Repeatable read）：

MySql默认隔离级别。

可避免 ***脏读*** 、***不可重复读*** 的发生。

  4.串行化（Serializable ）：

可避免 ***脏读、不可重复读、幻读*** 的发生。



### 了解哪些设计模式

#### 手敲代码实现单例模式

单例：减少对象的反复实例化，单例只初始化时实例一次对象

双锁单例

~~~java
public class DclSingleton{
  private volatile static DclSingleton dclSingleton;
  private DclSingleton(){
    
  }
  public static DclSingleton instance(){
    if(dclSingleton==null){
      synchronized(DclSingleton.class){
        if(dclSingleton==null){
          dclSingleton=new DclSingleton;
        }
      }
    }
    return dclSingleton;
  }
}
~~~

枚举单例

~~~java
public enum EnumSingleton{
  INSTANCE;
  private final CommonBean commonInstance;
  EnumSingleton{
    this.commonInstance = new CommonBean();
  }
  public CommonBean getInstance(){
    return this.commonInstance
  }
}
~~~

工厂：根据不同需求场景，使用一个类型工厂创建多种对象。例如使用图形工厂类，根据使用场景使用图形工厂类创建不同图形实例，使用工厂创建出来，而不是通过对象自己的构造函数创建。

~~~java
ShapeFactory shapeFactory = new ShapeFactory();
        // 画圆
        Shape circle = shapeFactory.getShape("CIRCLE");
        circle.draw();
        // 画方形
        Shape square = shapeFactory.getShape("SQUARE");
        square.draw();
        // 画三角
        Shape rectangle = shapeFactory.getShape("RECTANGLE");
        rectangle.draw();
~~~

生产消费：典型微服务生产消费者

策略模式：相同接口，多个实现类

### 题目

1. 随机生成 Salary {name, baseSalary, bonus }的记录，如“wxxx,10,1”，每行一条记录，总共1000万记录，写入文本文件（UFT-8编码），
   然后读取文件，name的前两个字符相同的，其年薪累加，比如wx，100万，3个人，最后做排序和分组，输出年薪总额最高的10组：
   wx, 200万，10人
   lt, 180万，8人
   ....
   name 4位a-z随机， baseSalary [0,100]随机 bonus[0-5]随机 年薪总额 = baseSalary*13 + bonus

请努力将程序优化到5秒内执行完

~~~java
@Getter@Setter@ToString
public class Salary  {
    private String name; //员工姓名
    private Integer baseSalary; //基础工资
    private Integer bonus; //奖金
}
/**
 * 生成1000w条随机数据
 */
public class SalaryTest {
    public static void main(String[] args) throws IOException {
        File file = new File("D:/upload/test.txt");
        FileWriter out = new FileWriter(file, true);
        Integer count = 10000000;
        while (true){
            StringBuilder name = new StringBuilder(4);
            String chars = "abcdefghijklmnopqrstuvwxyz";
            for (int i = 0 ; i < 4; i++){
                name.append(chars.charAt((int) (Math.random() * 26))) ;
            }
            Salary salary = new Salary();
            salary.setName(name.toString());
            salary.setBaseSalary((int) (Math.random() * 100 + 1));
            salary.setBonus((int) (Math.random() * 5 + 1));
            count --;
            out.write(JSON.toJSONString(salary));
            out.write("\n");
        if (count ==0){
            out.close();
            return;
        }

        }
    }
}
public class Test {

    public static void main(String[] args) throws IOException {
        long time = new Date().getTime();
        /**
         * 其实也可以用随机流;将文件分块;多起几个线程执行;
          这样的做的话得将文件分块;意思就是通过scan的api;先全文循环后标记;分成几份.
          1000w的数据不大.这样反而效率更低
         */
        BufferedReader reader = new BufferedReader(new FileReader("D:/upload/test.txt"));
        String line = null;
        HashMap<String,Salary> map = new HashMap();
        while((line = reader.readLine()) != null){
            Salary salary = JSON.parseObject(String.valueOf(line), Salary.class);
            String key = salary.getName().substring(0, 2);
            Salary result = map.get(key);
            if (result != null) {
                result.setBaseSalary(result.getBaseSalary() + salary.getBaseSalary() * 13 + salary.getBonus());
                result.setBonus(result.getBonus() +1);
            }else {
                result = new Salary();
                result.setName(key);
                result.setBonus(1);
                result.setBaseSalary(salary.getBaseSalary() * 13 + salary.getBonus());
                map.put(key,result);
            }
        }
        ArrayList<Salary> values = new ArrayList();

         Collection<Salary> co =   map.values();
        values.addAll(co);
      /**
      java8之后提供流排序;效率更高
    **/
        List<Salary> list = map.values().stream().sorted(new Comparator<Salary>() {
            @Override
            public int compare(Salary o1, Salary o2) {
                return o2.getBaseSalary() - o1.getBaseSalary();
            }
        }).collect(Collectors.toList());

       /* Collections.sort( values, new Comparator<Salary>() {
            public int compare(Salary o1, Salary o2) {
                return o2.getBaseSalary() - o1.getBaseSalary();
            }
        });
*/
        System.out.println((new Date().getTime() - time));
        for (int i =0 ; i < 10 ; i++){
            System.out.println(list.get(i));
        }        
   }
}
// 链接：https://www.jianshu.com/p/f092fb562c87
~~~

2. 使用二分查找的方式来定位某一元素

   对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，返回-1。若该元素出现多次，请返回第一次出现的位置。

~~~java
public int getBinarySearch(int[] nums,int n,int val){
  int high = n-1,low=0,mid=0,flag=-1;
  while(low<=high){
    if(nums[mid]==val){
      flag = mid
    }
    if(nums[mid]<val){
      low=mid+1;
    }
    if(nums[mid]>=val){
      high=mid-1;
    }
  }
  return flag;
}
~~~

3. 请用你熟悉的开发语言，完成如下题目:
   输入:若干个集合,各集合中的元素不会重复
   输出:求这些集合的笛卡尔积例如:
   输入:N个集合(这里N=3) :(a,b)(x,y)(1,2,3)
   输出: ((a,x,1), (a,x,2)…(b,y,3))
   在保证正确性的情况下尽可能优化效率，同时注意代码风格

4. 利用循环的方式实现我输入n 得到n对应的裴波拉契数字，裴波拉契举例：1 1 2 3 5 8 13 21 。。。。。。。

5. 用Java编写一个会导致死锁的程序

   ~~~java
   static Object lock1 = new Object();
   static Object lock2 = new Object();
   
   synchronized(lock1.class){
     synchronized(lock2.class){
       
     }
   }
   
   synchronized(lock2.class){
     synchronized(lock1.class){
       
     }
   }
   ~~~

   

6. Java写代码来解决生产者——消费者问题

   ~~~java
   ShareData shareData = new ShareData();
   // 生产
   for(int i=0;i<10;i++){
     new Thread(()->{
       shareData.increment();
     },"aaa"+i).start()
   }
   // 消费
   for(int i=0;i<10;i++){
     new Thread(()->{
       shareData.decrement();
     },"aaa"+i).start()
   }
   
   class ShareData(){
     private int num=0;
     private Lock lock = new ReentrantLock();
     private Condition condition = lock.newCondition();
     public void increment(){
       lock.lock();
       try{
         while(number!=0){
           condition.await();
         }
         number++;
         conditon.signAll();
       }catch(){
         
       }finally{
   			lock.unlock();
       }
     }
     
     public void decrement(){
       lock.lock();
       try{
         while(number==0){
           condition.await();
         }
         number--;
         condition.signAll();
       }catch(){
         
       }finally{
         lock.unlock();
       }
     }
   }
   
   
   ~~~

   

   